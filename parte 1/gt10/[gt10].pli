/* [gt10] - Dado um grafo G=(V,E) encontrar seu emparelhamento maximal mínimo */

/* Vértices */
set V;

/* Arestas - o 'within' diz que os elementos são de V, e o 'cross' faz um produto cartesiano entre os elementos de V, */
/* ou seja, E vai ser composto de pares de elementos de V */
set E, within V cross V;

/* Variável binária que diz se aresta i está ou não no emparelhamento */
var x{(i,j) in E}, binary;

/* A constraint abaixo garante que dois vértices adjacentes nunca estarão no emparelhamento */
s.t. vizinhoA{u in V}: sum{i in V: (i,u) in E}x[i,u] + sum{j in V: (u,j) in E}x[u,j] <= 1;

/* Essa constraint garante a maximalidade, ou seja, para cada aresta, entre ela e suas vizinhas */
/* devemos ter ao menos uma que faça parte do emparelhamento (pois se não houvesse, poderiamos  */
/* adicionar a aresta corrente no emparelhamento, e portanto não seria maximal */
s.t. maximal{(i,j) in E}:x[i,j] + 
            sum{u in V: (i,u) in E and u != j}x[i,u] +
            sum{u in V: (u,j) in E and u != i}x[u,j] >= 1;

/* A função objetivo minimiza o número de arestas no emparelhamento*/
minimize objetivo: sum{(i,j) in E} x[i,j];
